<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mango.optimizers.multiobjective_simulated_annealing &mdash; mango generative design framework b0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=7d16594f"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            mango generative design framework
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">mango</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mango generative design framework</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mango.optimizers.multiobjective_simulated_annealing</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mango.optimizers.multiobjective_simulated_annealing</h1><div class="highlight"><pre>
<span></span><span class="c1"># A.J. Vetturini</span>
<span class="c1"># IDIG and MMBL</span>
<span class="c1"># Carnegie Mellon University</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Currently this optimizer is only available for the PolyhedralSpace; future work will potentially need to incorporate</span>
<span class="sd">different spaces and update this class to allow different spaces.</span>

<span class="sd">This script incorporates the MOSA algorithm as developed by Suppapitnam, Seffen, Parks, and Clarkson in &quot;A Simulated</span>
<span class="sd">Annealing Algorithm for Multiobjective Optimization&quot; (Engineering Optimization, 2000, Vol 33. pp. 59-85)</span>

<span class="sd">There are some modifications made to the algorithm in reference to Suppapitnarm, Parks, Shea, and Clarkson in</span>
<span class="sd">&quot;Conceptual Design of Bicycle Frames by Multiobjective Shape Annealing&quot;.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Import Modules</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">mango.design_spaces.polyhedral_design_space</span> <span class="kn">import</span> <span class="n">PolyhedralSpace</span>
<span class="kn">from</span> <span class="nn">mango.grammars.origami_grammars</span> <span class="kn">import</span> <span class="n">GrammarSet</span><span class="p">,</span> <span class="n">CustomGrammarSet</span>
<span class="kn">from</span> <span class="nn">mango.optimizers</span> <span class="kn">import</span> <span class="n">design_constraints</span>
<span class="kn">from</span> <span class="nn">mango.utils.math</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">randint</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">dill</span>
<span class="kn">import</span> <span class="nn">shutil</span>

<div class="viewcode-block" id="MOSA">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">MOSA</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The optimizer is the &quot;heart and soul&quot; of the framework. It contains the logic for applying grammars and controlling</span>
<span class="sd">    the optimization-driven generative process. There are various hyperparameters that can be tuned which establish</span>
<span class="sd">    the depth of search and time spent searching.</span>

<span class="sd">    This data class contains the multiobjective shape annealing (MOSA) algorithm implementation and is set to solve a</span>
<span class="sd">    MOP with at least 2 objectives defined, but technically any N number of constraints can be input. However, MOSA has</span>
<span class="sd">    only been tested with 2 or 3 objectives, so any higher dimensionality must be analyzed with detail.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    design_space : Initial PolyhedralSpace representing the design which is to be optimized</span>
<span class="sd">    grammars : A singular GrammarSet or a list of GrammarSets to use in the generative process</span>
<span class="sd">    design_constraints : The PolyhedralDesignConstraint object which constraint the optimizer</span>
<span class="sd">    objective_functions : List of at least 2 objective function objects to be minimized</span>
<span class="sd">    SAVE_PATH : Path of where to save the resultant generative .aj1 file</span>
<span class="sd">    SAVE_NAME_NO_EXTENSION : Filename of resultant .aj1 file</span>
<span class="sd">    constraint_set : List of constraint name strings that are checked by the optimizer by default</span>

<span class="sd">    Optional / Other input parameters that can be changed:</span>
<span class="sd">    ------------</span>
<span class="sd">    extension_value_default : Default node extension value to use (default: 0.34 nm)</span>
<span class="sd">    extension_ramp : Dictionary mapping a extension grammar to a Ramp element</span>
<span class="sd">    rotation_value_degrees_default : Default edge rotation value to use (default: 1 degrees)</span>
<span class="sd">    rotation_ramp: Dictionary mapping a rotation grammar to a Ramp element</span>
<span class="sd">    numDecimals : Number of decimal places to round to</span>
<span class="sd">    print_progress : Bool which determines if messages are printed to the terminal (default: TRUE)</span>

<span class="sd">    Multiobjective Simulated Annealing Hyperparameters that can be controlled</span>
<span class="sd">    Note that the default parameters here won&#39;t necessarily give a &quot;good&quot; result, they must be tuned!</span>
<span class="sd">    ------------</span>
<span class="sd">    NT1 : Number of random walk steps to initialize the temperature of the space (default: 2000)</span>
<span class="sd">    NT2 : Number of inner-loop mutations to consider before lowering temperature (default: 400)</span>
<span class="sd">    Na : Number of accepted design solutions to consider before lowering temperature (default: 400, 0.4*NT2)</span>
<span class="sd">    r_b : Return to base parameter in range (0, 1) and dictates frequency of changing active design (default: 0.95)</span>
<span class="sd">    acceptance_function : Controls how often &quot;worse&quot; moves are accepted (default: standard)</span>
<span class="sd">    cooling_schedule : Cooling schedule used during simulated annealing (default: huang / HRSV)</span>
<span class="sd">    N_Bi : Number of iterations before returning to base (default: 800, 2*NT2)</span>
<span class="sd">    N_Bi_LowerLimit : Lower limit on number of iterations before conducting return to base (default: 25)</span>
<span class="sd">    minimal_candidate_set_size : Lower limit on number of designs to consider when returning to base (default: 10)</span>
<span class="sd">    r_i : Parameter controlling how large the candidate set size is in range (0, 1) (default: 0.95)</span>
<span class="sd">    max_time_of_optimization_minutes : Max time spent generating a design (default: 60 minutes)</span>
<span class="sd">    T_min : Minimal temperature to end the annealing process (default: 1e-8)</span>
<span class="sd">    cooling_rate_geometric : Cooling rate to use if using geometric cooling_schedule (default: 0.9)</span>
<span class="sd">    delta_T : Triki annealing schedule adaptation rate, only used if using triki cooling_schedule (default: 0.8)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input parameters that must be passed in:</span>
    <span class="n">design_space</span><span class="p">:</span> <span class="n">PolyhedralSpace</span>
    <span class="n">grammars</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GrammarSet</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span>  <span class="c1"># Pass a list of any grammar sets used.</span>
    <span class="n">design_constraints</span><span class="p">:</span> <span class="n">design_constraints</span>
    <span class="n">objective_functions</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">SAVE_PATH</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># This is where the output dill file is saved to</span>
    <span class="n">SAVE_NAME_NO_EXTENSION</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">constraint_set</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Outside Design Space&#39;</span><span class="p">,</span> <span class="s1">&#39;Vertex in Excluded&#39;</span><span class="p">,</span> <span class="s1">&#39;Edge in Excluded&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;Invalid Edge Length&#39;</span><span class="p">,</span> <span class="s1">&#39;Invalid Scaffold Length&#39;</span><span class="p">,</span> <span class="s1">&#39;Invalid Face Angle&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;Broken preserved edge&#39;</span><span class="p">,</span> <span class="s1">&#39;Intersecting edges&#39;</span><span class="p">,</span> <span class="s1">&#39;Intersecting faces&#39;</span><span class="p">])</span>

    <span class="c1"># Various input parameters that can be changed:</span>
    <span class="n">extension_value_default</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.34</span>  <span class="c1"># Default value if ramp is not used</span>
    <span class="n">extension_ramp</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">rotation_value_degrees_default</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rotation_ramp</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="c1"># Determines if a ramp is being used for rotation(True) which ignores above var.</span>
    <span class="n">numDecimals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">max_number_of_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Random seed a user can specify</span>

    <span class="c1">## Hyperparameters that can be tuned by user:</span>
    <span class="n">NT1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2000</span>  <span class="c1"># (1000 recommended for Initial temperature calculation as recommended by authors of MOSA)</span>
    <span class="n">NT2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="n">Na</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span>  <span class="c1"># Inner loop control, = 0.4NT2 per MOSA algo</span>
    <span class="n">r_b</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span>  <span class="c1"># Return to base parameter in (0, 1) and dictates frequency of return</span>
    <span class="n">acceptance_function</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Standard&#39;</span>
    <span class="n">cooling_schedule</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Huang&#39;</span>
    <span class="c1"># (close to 1 == more returns over time == greater &quot;depth&quot;)</span>
    <span class="n">N_Bi</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># 2 * NT2 is default. Controls initial # of returns. Larger value == deeper search</span>
    <span class="n">N_Bi_LowerLimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span>  <span class="c1"># Lower limit for # of grammars to successfully apply before return to base</span>
    <span class="n">minimal_candidate_set_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">r_i</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span>  <span class="c1"># Return fraction parameter, recommended at least 0.9 but can be in (0, 1)</span>
    <span class="n">max_time_of_optimization_minutes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">60</span>  <span class="c1"># Number of minutes before exiting the optimization for protection</span>
    <span class="n">print_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">T_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span>  <span class="c1"># Because of math the temperature will never truly be 0 so we need a stop point</span>

    <span class="c1"># Cooling Schedule Parameters depending on schedule used (Huang is recommended)</span>
    <span class="n">cooling_rate_geometric</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span>  <span class="c1"># The cooling schedule for geometric (only used if Geoemtric schedule is used)</span>
    <span class="n">delta_T</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span>  <span class="c1"># Used with the Triki annealing schedule and controls adaptation. May need to modify this.</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">## Dummy variables that I initialize here to prevent users from &quot;touching&quot; them:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_checked</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accepted_via_probability</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_time_seconds</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_all_temp</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temp_tracker</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">archive_post_temperature_initialization</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pareto_animation</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_r</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Parameter that will be used across algorithm for return to base calcs, do not change from 1!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objectives</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_accept_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_tracker</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_per_epoch</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Run initialization methods:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000000</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No random seed specified, using the following seed number: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># Initialize here:</span>
        <span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammars</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># In the case that multiple GrammarSets are prescribed, we need to &quot;combine&quot; them:</span>
            <span class="c1"># First validate they are GrammarSets:</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammars</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">GrammarSet</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Each GrammarSet in the list of grammars must be a GrammarSet datatype, you &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;specified: </span><span class="si">{</span><span class="n">g</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># Also set the seed in this grammar_set</span>
                <span class="n">g</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="n">seed_number</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>

            <span class="c1"># If all are grammar sets then we use the &quot;Combined&quot; GrammarSet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span> <span class="o">=</span> <span class="n">CustomGrammarSet</span><span class="p">(</span><span class="n">grammar_sets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grammars</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammars</span><span class="p">,</span> <span class="n">GrammarSet</span><span class="p">):</span>
            <span class="c1"># In the case a singular set of grammars are specifed (the most common case), we just set grammar_set to</span>
            <span class="c1"># grammars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grammars</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="n">seed_number</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If grammars is neither, then raise an error:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The value of grammars must be either a list of GrammarSet&#39;s or a singular GrammarSet, &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;you specified: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grammars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Validate ramp conditions:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_ramp</span> <span class="o">!=</span> <span class="p">{}:</span>
            <span class="c1"># If the user specifies an extension_ramp, then we must validate the values to ensure it is a proper</span>
            <span class="c1"># data structure:</span>
            <span class="k">for</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">ramp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_ramp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">grammar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span><span class="o">.</span><span class="n">grammar_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Invalid ramp specified for </span><span class="si">{</span><span class="n">grammar</span><span class="si">}</span><span class="s1"> as this grammar is not in the list of grammars &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;specified to the problem.&#39;</span><span class="p">)</span>
            <span class="c1"># If we validate all ramps w/o error, then we just set the flag to true:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_extension_ramp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_extension_ramp</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Repeat above for the rotation_ramp.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_ramp</span> <span class="o">!=</span> <span class="p">{}:</span>
            <span class="k">for</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">ramp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_ramp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">grammar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span><span class="o">.</span><span class="n">grammar_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Invalid ramp specified for </span><span class="si">{</span><span class="n">grammar</span><span class="si">}</span><span class="s1"> as this grammar is not in the list of grammars &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;specified to the problem.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_rotation_ramp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_rotation_ramp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_objective_function_lists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verify_input_values</span><span class="p">()</span>


<div class="viewcode-block" id="MOSA.update_design_space">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.update_design_space">[docs]</a>
    <span class="k">def</span> <span class="nf">update_design_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_design_space</span><span class="p">:</span> <span class="n">PolyhedralSpace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function updates the active design_space object whenever return-to-base is enacted or whenever the space</span>
<span class="sd">        needs to be re-assigned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design_space</span> <span class="o">=</span> <span class="n">new_design_space</span></div>



<div class="viewcode-block" id="MOSA.verify_input_values">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.verify_input_values">[docs]</a>
    <span class="k">def</span> <span class="nf">verify_input_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function that simply validates the input parameters before starting an optimization process. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Standard&#39;</span><span class="p">,</span> <span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="s1">&#39;logistic&#39;</span><span class="p">,</span> <span class="s1">&#39;Logistic&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;Linear&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid acceptance function input, only values are: standard, logistic, linear&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cooling_schedule</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;geometric&#39;</span><span class="p">,</span> <span class="s1">&#39;Geometric&#39;</span><span class="p">,</span> <span class="s1">&#39;triki&#39;</span><span class="p">,</span> <span class="s1">&#39;Triki&#39;</span><span class="p">,</span> <span class="s1">&#39;Huang&#39;</span><span class="p">,</span> <span class="s1">&#39;huang&#39;</span><span class="p">,</span> <span class="s1">&#39;HRSV&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid cooling schedule input, only values are: geometric, triki, huang&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="MOSA.initialize_objective_function_lists">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.initialize_objective_function_lists">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_objective_function_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Initializes lists and dictionaries for tracking relevent properties during optimization process &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_functions</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid list of objective functions used, the list must be at least length 2 (i.e., 2 &#39;</span>
                            <span class="s1">&#39;objectives must be defined for a multi-objective optimization problem!&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">objective</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_functions</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># Initialize a temperature value of &quot;100&quot; as just a &quot;dummy&quot; value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># This is a list tracking the obj. func values for an epoch</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_all_temp</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">temp_tracker</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># This list will track the temperatures at each epoch</span></div>



<div class="viewcode-block" id="MOSA.initialize_time_tracker_dict">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.initialize_time_tracker_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_time_tracker_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Initialize a dictionary to track time for internal development purposes &quot;&quot;&quot;</span>
        <span class="c1"># first create keys for the grammars and constraints. We use &quot;0&quot; since a time-to-execute will never be less than</span>
        <span class="c1"># 0 and these are just tracking the execution-times of these functions.</span>
        <span class="k">for</span> <span class="n">grammar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span><span class="o">.</span><span class="n">grammar_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">grammar</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_constraints</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Add in some defaults for the timer</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_functions</span><span class="p">:</span>
            <span class="n">nameMax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_max_time&quot;</span>
            <span class="n">nameMin</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_min_time&quot;</span>
            <span class="c1"># Initialize the max and min values to values that will get over-written during the tracking process</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">nameMax</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">nameMin</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e6</span></div>



<div class="viewcode-block" id="MOSA.calculate_objective_function_values">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.calculate_objective_function_values">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_objective_function_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">design_space</span><span class="p">:</span> <span class="n">PolyhedralSpace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is responsible for evaluating the design_space using the input objective functions. It also</span>
<span class="sd">        records all execution times of the objective functions for internal development purposes.</span>

<span class="sd">        :param design_space: Design space that is currently being evaluated</span>
<span class="sd">        :returns: List of floating point values of the objective function valuations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_edge_lengths</span> <span class="o">=</span> <span class="n">calculate_design_edge_lengths</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">design_space</span><span class="o">.</span><span class="n">design_graph</span><span class="p">)</span>
        <span class="n">input_params</span> <span class="o">=</span> <span class="n">design_space</span><span class="o">.</span><span class="n">calculate_input_parameters</span><span class="p">(</span><span class="n">edge_lengths</span><span class="o">=</span><span class="n">all_edge_lengths</span><span class="p">,</span>
                                                               <span class="n">routing_algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">design_constraints</span><span class="o">.</span><span class="n">scaffold_routing_algorithm</span><span class="p">)</span>
        <span class="n">obj_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_functions</span><span class="p">:</span>
            <span class="n">nameMax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_max_time&quot;</span>
            <span class="n">nameMin</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_min_time&quot;</span>
            <span class="n">st_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">obj_val</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">evaluate_function</span><span class="p">(</span><span class="n">input_params</span><span class="p">)</span>
            <span class="n">end_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">elapsed</span> <span class="o">=</span> <span class="n">end_t</span> <span class="o">-</span> <span class="n">st_t</span>
            <span class="c1"># RECORD TIMES</span>
            <span class="k">if</span> <span class="n">elapsed</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">nameMax</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">nameMax</span><span class="p">]</span> <span class="o">=</span> <span class="n">elapsed</span>
            <span class="k">if</span> <span class="n">elapsed</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">nameMin</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">nameMin</span><span class="p">]</span> <span class="o">=</span> <span class="n">elapsed</span>
            <span class="c1"># RECORD OBJECTIVE FUNCTION VALUE</span>
            <span class="n">obj_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj_values</span></div>



<div class="viewcode-block" id="MOSA.archive_datapoint">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.archive_datapoint">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">archive_datapoint</span><span class="p">(</span><span class="n">archive</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">test_point</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function will take in the current archived points as well as a test point to determine if I need to archive</span>
<span class="sd">        the point (and do this archiving if needed).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Internal function to determine if a point is dominating or not:</span>
        <span class="k">def</span> <span class="nf">dominates</span><span class="p">(</span><span class="n">new_point</span><span class="p">,</span> <span class="n">archived_point</span><span class="p">):</span>
            <span class="c1"># p1 dominates p2 if it&#39;s better in at least one objective and not worse in any objective</span>
            <span class="c1"># unpacking but in the future I should make this code more efficient, right now i have it for readability</span>
            <span class="n">no_worse_in_any_objective</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Assume that the new_point is no worse in any objective to start</span>
            <span class="n">strictly_better_in_at_least_one</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Assume False to start</span>
            <span class="k">for</span> <span class="n">f_new</span><span class="p">,</span> <span class="n">f_old</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_point</span><span class="p">,</span> <span class="n">archived_point</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">f_new</span> <span class="o">&lt;</span> <span class="n">f_old</span><span class="p">:</span>
                    <span class="n">strictly_better_in_at_least_one</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># If a new point is better in at least one, we say True</span>
                <span class="k">elif</span> <span class="n">f_new</span> <span class="o">&gt;</span> <span class="n">f_old</span><span class="p">:</span>
                    <span class="n">no_worse_in_any_objective</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># if f_new is ever larger than f_old in any objective, then</span>
                    <span class="c1"># it is no longer no worse in an objective</span>

            <span class="c1"># Now we just return these two booleans which determines dominance:</span>
            <span class="k">return</span> <span class="n">no_worse_in_any_objective</span> <span class="ow">and</span> <span class="n">strictly_better_in_at_least_one</span>

        <span class="c1">### CASE 1: If a candidate solution dominates any member(s) of the archive, those members are removed and the</span>
        <span class="c1">#           new solution is added.</span>
        <span class="c1"># Find dominated points in the archive and mark their indices for removal:</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">archive_point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">archive</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dominates</span><span class="p">(</span><span class="n">new_point</span><span class="o">=</span><span class="n">test_point</span><span class="p">,</span> <span class="n">archived_point</span><span class="o">=</span><span class="n">archive_point</span><span class="p">):</span>
                <span class="c1"># This case means that the test point dominates the archive point meaning we need to remove archive</span>
                <span class="c1"># point from the pareto:</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">archive_point</span><span class="p">)</span>
        <span class="c1"># If to_remove has any points added then we know that our archive point dominates at least 1 point and is</span>
        <span class="c1"># therefore added to the archive (by returning True) and we remove the points in the to_remove list.</span>
        <span class="k">if</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">to_remove</span>

        <span class="c1">### CASE 2: If a new solution is dominated by any members of the archive, it is not archived:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">archive_point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">archive</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dominates</span><span class="p">(</span><span class="n">archive_point</span><span class="p">,</span> <span class="n">test_point</span><span class="p">):</span>
                <span class="c1"># If any solution in the archive is dominating the test_point, we return False to not add to archive.</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">to_remove</span>

        <span class="c1">### CASE 3: If a test_point does not dominate any solution in the archive, and it is not dominated by any</span>
        <span class="c1">#           member of the archive, we DO store the point, but we do NOT remove any from the list. However, here</span>
        <span class="c1">#           the to_remove will ALWAYS by of value [] (empty) so we can just return it like that:</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">to_remove</span></div>



<div class="viewcode-block" id="MOSA.calculate_and_store_objective_function_values">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.calculate_and_store_objective_function_values">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_and_store_objective_function_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">design_space</span><span class="p">:</span> <span class="n">PolyhedralSpace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is called so that the objective functions are stored to analyze the optimization performance.</span>

<span class="sd">        :param design_space: Design space that is currently being evaluated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_objectives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_objective_function_values</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="n">design_space</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_objectives</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_objectives</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_all_temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_objectives</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">archive_data</span><span class="p">,</span> <span class="n">remove_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">archive_datapoint</span><span class="p">(</span><span class="n">archive</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                                           <span class="n">test_point</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_objectives</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">archive_data</span><span class="p">:</span>
            <span class="c1"># This removal loop will only be needed if we are archiving a point, if we are not archiving a point we will</span>
            <span class="c1"># never be removing a point</span>
            <span class="k">for</span> <span class="n">remove_from_archive</span> <span class="ow">in</span> <span class="n">remove_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">remove_from_archive</span><span class="p">)</span>

            <span class="c1"># Archive is stored as (magnitudes of objective functions) : design_space object</span>
            <span class="n">newKey</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_objectives</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span><span class="p">[</span><span class="n">newKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">design_space</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOSA.get_extend_and_rotation_values">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.get_extend_and_rotation_values">[docs]</a>
    <span class="k">def</span> <span class="nf">get_extend_and_rotation_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If a ramp is being used, this method gets the current value to use and return it</span>

<span class="sd">        :param epoch: Current epoch number to obtain extension value from ramp</span>
<span class="sd">        :return: Extension value and rotation value as a tuple: (extension, rotation)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extension_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_extension_ramp</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">ramp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_ramp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">extension_value</span> <span class="o">=</span> <span class="n">ramp</span><span class="o">.</span><span class="n">current_ramp_value</span><span class="p">(</span><span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">)</span>  <span class="c1"># We take in the max ramp value</span>
                <span class="n">extension_map</span><span class="p">[</span><span class="n">grammar</span><span class="p">]</span> <span class="o">=</span> <span class="n">extension_value</span>

        <span class="c1"># Now, if the user is not using a ramp / for grammars not in the ramp we use the default value. Note that some</span>
        <span class="c1"># of these grammars dont even use an extension / rotation value but we return one anyways due to the structure</span>
        <span class="c1"># of the functions. The value is essentially &quot;unused&quot; but we still need to access it.</span>
        <span class="k">for</span> <span class="n">grammar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span><span class="o">.</span><span class="n">grammar_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">grammar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">extension_map</span><span class="p">:</span>
                <span class="n">extension_map</span><span class="p">[</span><span class="n">grammar</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_value_default</span>

        <span class="c1"># Repeat above for rotation_map</span>
        <span class="n">rotation_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotation_ramp</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">ramp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_ramp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">extension_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ramp</span><span class="o">.</span><span class="n">current_ramp_value</span><span class="p">(</span><span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">))</span>  <span class="c1"># We take in the max ramp value</span>
                <span class="n">rotation_map</span><span class="p">[</span><span class="n">grammar</span><span class="p">]</span> <span class="o">=</span> <span class="n">extension_value</span>

        <span class="k">for</span> <span class="n">grammar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span><span class="o">.</span><span class="n">grammar_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">grammar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rotation_map</span><span class="p">:</span>
                <span class="n">rotation_map</span><span class="p">[</span><span class="n">grammar</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_value_degrees_default</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">extension_map</span><span class="p">,</span> <span class="n">rotation_map</span></div>



<div class="viewcode-block" id="MOSA.initialize_temperatures">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.initialize_temperatures">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_temperatures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function performs a random walk through the objective space to automatically assign the temperature used</span>
<span class="sd">        in the acceptance criterion for the first epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start by evaluating the current start shape:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_and_store_objective_function_values</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="p">)</span>

        <span class="c1"># In a random walk we will ALWAYS accept a move, but we need a counter and while loop since we can still</span>
        <span class="c1"># violate constraints</span>
        <span class="n">accepted_moves</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">while_loop_counter</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Prevent infinite loop</span>

        <span class="c1"># Get the extension value from the ramp. This will return the defaults if a ramp is not used as a note!</span>
        <span class="n">extension_map</span><span class="p">,</span> <span class="n">rotation_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extend_and_rotation_values</span><span class="p">(</span><span class="n">epoch</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Random Walk:</span>
        <span class="k">while</span> <span class="n">accepted_moves</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">NT1</span><span class="p">:</span>
            <span class="n">candidate_design_state</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="p">)</span>
            <span class="n">new_grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span><span class="o">.</span><span class="n">pick_random_grammar</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;rotation&#39;</span> <span class="ow">in</span> <span class="n">new_grammar</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">or</span> <span class="s1">&#39;rotate&#39;</span> <span class="ow">in</span> <span class="n">new_grammar</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">rotation_map</span><span class="p">[</span><span class="n">new_grammar</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">extension_map</span><span class="p">[</span><span class="n">new_grammar</span><span class="p">]</span>

            <span class="c1"># Randomly apply grammar and validate the design constraints:</span>
            <span class="n">grammar_applied_successfully</span><span class="p">,</span> <span class="n">grammar_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span><span class="o">.</span><span class="n">call_grammar_function</span><span class="p">(</span>
                <span class="n">grammar_selected</span><span class="o">=</span><span class="n">new_grammar</span><span class="p">,</span>
                <span class="n">design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">,</span>
                <span class="n">extension_value</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span>
            <span class="c1"># Update the design constraint values and calculate if design is compliant:</span>
            <span class="k">if</span> <span class="n">grammar_applied_successfully</span><span class="p">:</span>
                <span class="c1"># Update the design constraint values and calculate if design is compliant:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">design_constraints</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">)</span>
                <span class="n">passed_all_constraints</span><span class="p">,</span> <span class="n">constraint_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_constraints</span><span class="o">.</span><span class="n">check_constraints</span><span class="p">(</span>
                    <span class="n">design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">,</span> <span class="n">constraint_set</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_set</span><span class="p">,</span>
                    <span class="n">compare_space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the grammar didn&#39;t apply just set this to False. Doesn&#39;t need to be this way but ;-)</span>
                <span class="n">passed_all_constraints</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">grammar_applied_successfully</span> <span class="ow">and</span> <span class="n">passed_all_constraints</span><span class="p">:</span>
                <span class="c1"># If the grammar is applied successfully and the constraints are all passed then this new state replaces</span>
                <span class="c1"># the current design_space</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_and_store_objective_function_values</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_design_space</span><span class="p">(</span><span class="n">new_design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">)</span>
                <span class="n">accepted_moves</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1">#  No matter what, we delete this candidate from memory so it re-instantiates in while loop for peace of</span>
            <span class="c1">#  mind regarding objects. If the design_space was accepted in if above, then this all works out!</span>
            <span class="k">del</span> <span class="n">candidate_design_state</span>

            <span class="c1"># For the sake of no infinite loops, I use a while loop counter here to ensure it doesn&#39;t get stuck:</span>
            <span class="n">while_loop_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">while_loop_counter</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">NT1</span><span class="p">):</span>  <span class="c1"># Prevent infinite loop</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unable to apply </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">NT1</span><span class="si">}</span><span class="s1"> without violating design constraints which may lead to &#39;</span>
                              <span class="sa">f</span><span class="s1">&#39;an inferior solution set, be aware!&#39;</span><span class="p">)</span>
                <span class="n">accepted_moves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NT1</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Just break the loop condition...</span>


        <span class="c1"># After performing the random walk, we use the methodology from S. R. White from &quot;Concepts of scale in</span>
        <span class="c1">#         # simulated annealing. IEEE International Conference of Computer Aided Design, Port Chester, New York.</span>
        <span class="c1">#         # pp. 646-651&quot; to initialize each temperature of each objective function:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">newTemp</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">val</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDecimals</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">newTemp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Reset these lists as we will return to base after initializing</span>
            <span class="c1"># Check and make sure the temperature is not 0:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_functions</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;MOSA could not find any variation in the objective function valuations for the&#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;specified function </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">. Please increase NT1 or verify the objective function &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;is actually evaluating at different values.&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># We store the post-random walk Pareto for visualization purposes:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">archive_post_temperature_initialization</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="MOSA.calculate_pareto_isolation">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.calculate_pareto_isolation">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_pareto_isolation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to rank and calculate the isolations of the pareto front during optimization.</span>
<span class="sd">        :return: Pandas dataframe containing candidate designs to return to base to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pareto</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># First I am going to split the pareto into lists for each objective function:</span>
        <span class="n">transposed_tuples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">pareto</span><span class="p">))</span>
        <span class="n">maxBRF</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">transposed_tuples</span><span class="p">]</span>
        <span class="n">minBRF</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">transposed_tuples</span><span class="p">]</span>


        <span class="c1"># Loop over all solutions</span>
        <span class="n">isolation_dict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to track measures of isolation</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pareto</span><span class="p">:</span>
            <span class="c1"># Our inner loop is for all other solutions in the pareto</span>
            <span class="n">Iij</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pareto</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="c1"># Here nothing happens because we don&#39;t compare the isolation of the same point</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Calculate isolation value for this index:</span>
                    <span class="k">for</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">FMAX</span><span class="p">,</span> <span class="n">FMIN</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">maxBRF</span><span class="p">,</span> <span class="n">minBRF</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">FMAX</span> <span class="o">==</span> <span class="n">FMIN</span><span class="p">:</span>
                            <span class="k">pass</span>
                            <span class="c1"># If FMAX and FMIN are the same then there is only one point in the Pareto set so we prevent</span>
                            <span class="c1"># a divide-by-zero error by just passing along.</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">Iij</span> <span class="o">+=</span> <span class="p">(((</span><span class="n">f1</span> <span class="o">-</span> <span class="n">f2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">FMAX</span> <span class="o">-</span> <span class="n">FMIN</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Before continuing, we store this isolation measure:</span>
            <span class="n">isolation_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Iij</span>

        <span class="c1"># After calculating all isolation values, we then rank in order of decreasing isolation distance WITH THE</span>
        <span class="c1"># EXCEPTION of the extreme solutions (i.e. solutions corresponding to extrema in the trade-off / solutions</span>
        <span class="c1"># with the lowest objective function. Sorting the dictionary:</span>
        <span class="n">points</span><span class="p">,</span> <span class="n">isolations</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;for k, v in isolation_dict.items():</span>
<span class="sd">            # Since I am currently using a relatively simple objective function space, I will not remove the extrema</span>
<span class="sd">            # datapoints, as these do not explicitly constitute a barely feasible solution.</span>
<span class="sd">            if any(val in minBRF for val in k):</span>
<span class="sd">                # If the point we are checking contains a point in the extrema (which in this case is a MINIMIZATION</span>
<span class="sd">                # problem), then we are not going to choose it in our return to base</span>
<span class="sd">                continue</span>
<span class="sd">            else:</span>
<span class="sd">                # If the point is not an extrema, we are going to add it to this 2D list:</span>
<span class="sd">                points.append(k)</span>
<span class="sd">                isolations.append(v)&#39;&#39;&#39;</span>
        <span class="c1"># For safety and if NT1 is too small, we check to see if points and isolations are empty, and if so, we add</span>
        <span class="c1"># the isolation dict values:</span>
        <span class="k">if</span> <span class="n">points</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">isolations</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">isolation_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">isolations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># Combining into a dataframe to sort by descending order per MOSA algorithm:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="n">points</span><span class="p">,</span> <span class="s1">&#39;isolations&#39;</span><span class="p">:</span> <span class="n">isolations</span><span class="p">})</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;isolations&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">datapoints</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">selection_set_size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_r</span> <span class="o">*</span> <span class="n">datapoints</span><span class="p">)</span>  <span class="c1"># Rounding because we need an integer # of points to pick</span>
        <span class="c1"># We also incorporate a minimal selection set size to prevent ever focusing in on just a few solutions:</span>
        <span class="k">if</span> <span class="n">selection_set_size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal_candidate_set_size</span><span class="p">:</span>
            <span class="n">selection_set_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal_candidate_set_size</span>

        <span class="c1"># We select the first &quot;selection_set_size&quot; number of points to be into &quot;candidate solutions&quot; we will choose from</span>
        <span class="n">candidate_list</span> <span class="o">=</span> <span class="n">df</span><span class="p">[:</span><span class="n">selection_set_size</span><span class="p">]</span>

        <span class="c1"># After creating the candidate list, we update values for future selections. But we only do this when we are not</span>
        <span class="c1"># performing the initial walk through space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_r</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_i</span>

        <span class="k">return</span> <span class="n">candidate_list</span></div>



<div class="viewcode-block" id="MOSA.return_to_base">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.return_to_base">[docs]</a>
    <span class="k">def</span> <span class="nf">return_to_base</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The return to base functionality is used to expose the trade-off between objective functions. The return to base</span>
<span class="sd">        will randomly change the active design state to somewhere else within the Pareto so that we optimize the</span>
<span class="sd">        pareto front</span>

<span class="sd">        Here we utilize the &quot;intelligent&quot; return-to-base strategy laid out in Conceptual Design of Bicycle Frames by</span>
<span class="sd">        Multiobjective Shape Annealing. The purpose is to prefer to &quot;return to base&quot; to extreme solutions (or highly</span>
<span class="sd">        isolated solutions) to explore around these unknown areas of the design space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First we calculate the pareto isolation parameter to determine where we will &quot;return to base&quot; to search</span>
        <span class="n">candidate_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_pareto_isolation</span><span class="p">()</span>

        <span class="c1"># Finally, we randomly select a single candidate to become the new active state:</span>
        <span class="n">new_state</span> <span class="o">=</span> <span class="n">candidate_list</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_state</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_state</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">])</span>  <span class="c1"># Convert the datatype...</span>
        <span class="n">store_state</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_state</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">new_state_data_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span><span class="p">[</span><span class="n">store_state</span><span class="p">]</span>

        <span class="c1"># Lastly, before returning the data object, we update the N_Bi term which dictates how often we will return to</span>
        <span class="c1"># base during the search. In general, the longer the search the more often we return to base to exploit the</span>
        <span class="c1"># tradeoffs of the objective functions:</span>

        <span class="c1"># We only lower these values once we start the actual MOSA search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_Bi</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r_b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_Bi</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_Bi</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_Bi_LowerLimit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N_Bi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_Bi_LowerLimit</span>  <span class="c1"># If we ever go below the lower limit, we just set N_Bi to the limit</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_design_space</span><span class="p">(</span><span class="n">new_design_space</span><span class="o">=</span><span class="n">new_state_data_object</span><span class="p">)</span></div>



<div class="viewcode-block" id="MOSA.keep_annealing">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.keep_annealing">[docs]</a>
    <span class="k">def</span> <span class="nf">keep_annealing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">numEpochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function determines when the MOSA algorithm should end based on either a set number of epochs, a length</span>
<span class="sd">        of time, or if the temperature hyperparameters get too low</span>

<span class="sd">        :param numEpochs: Current epoch of MOSA</span>
<span class="sd">        :param start_time: Start time of how long the inner while loop has been running</span>
<span class="sd">        :return: True = Keep running, False = END</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="n">hours</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span> <span class="mi">3600</span><span class="p">)</span>
        <span class="n">minutes</span><span class="p">,</span> <span class="n">seconds</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
        <span class="n">time_formatted</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:0&gt;2}</span><span class="s2">:</span><span class="si">{:0&gt;2}</span><span class="s2">:</span><span class="si">{:05.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hours</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">minutes</span><span class="p">),</span> <span class="n">seconds</span><span class="p">)</span>

        <span class="c1">### First check if temperatures are low enough to end the run:</span>
        <span class="k">for</span> <span class="n">temp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_min</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;MOSA ended due to temperatures dropping below threshold of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">T_min</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_time</span> <span class="o">=</span> <span class="n">time_formatted</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1">### Next check if max time has elapsed</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_time_of_optimization_minutes</span> <span class="o">*</span> <span class="mi">60</span><span class="p">):</span>
            <span class="c1"># If the current elapsed time is greater than the threshold in seconds (why i multiply by 60 above), we end</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;MOSA ended due to max time input of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_time_of_optimization_minutes</span><span class="si">}</span><span class="s1"> minutes&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_time</span> <span class="o">=</span> <span class="n">time_formatted</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">numEpochs</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_number_of_epochs</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;MOSA ended due to max number of epochs of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_number_of_epochs</span><span class="si">}</span><span class="s1"> being met&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_time</span> <span class="o">=</span> <span class="n">time_formatted</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise we return True meaning we keep looping</span>
            <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="MOSA.update_constraint_time_tracker">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.update_constraint_time_tracker">[docs]</a>
    <span class="k">def</span> <span class="nf">update_constraint_time_tracker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_times</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Updates time tracked with new_times dictionary &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dc_name</span><span class="p">,</span> <span class="n">ti</span> <span class="ow">in</span> <span class="n">new_times</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ti</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">dc_name</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">dc_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">dc_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span></div>



<div class="viewcode-block" id="MOSA.attempt_to_archive">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.attempt_to_archive">[docs]</a>
    <span class="k">def</span> <span class="nf">attempt_to_archive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidate_design</span><span class="p">:</span> <span class="n">PolyhedralSpace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function will be used to determine if a point is archived or not during the inner while loop of MOSA</span>

<span class="sd">        :param candidate_design: Design space after applying a grammar that is being considered.</span>
<span class="sd">        :return: True if the point was ACCEPTED and False if the point was REJECTED</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate objective function values and pass to archive function:</span>
        <span class="n">objective_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_objective_function_values</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="n">candidate_design</span><span class="p">)</span>
        <span class="n">archive_data</span><span class="p">,</span> <span class="n">remove_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">archive_datapoint</span><span class="p">(</span><span class="n">archive</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                                           <span class="n">test_point</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">objective_vals</span><span class="p">))</span>

        <span class="c1"># If we are archiving the data point we use the same logic to update the dictionary depending on dominance</span>
        <span class="k">if</span> <span class="n">archive_data</span><span class="p">:</span>
            <span class="c1"># First store the objective functions values into the proper tracker lists:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objective_vals</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objective_vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_all_temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objective_vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># This removal loop will only be needed if we are archiving a point, if we are not archiving a point we will</span>
            <span class="c1"># never be removing a point as remove_list will be blank.</span>
            <span class="k">for</span> <span class="n">remove_from_archive</span> <span class="ow">in</span> <span class="n">remove_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">remove_from_archive</span><span class="p">)</span>

            <span class="c1"># Archive is stored as (magnitudes of objective functions) : design_space object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">objective_vals</span><span class="p">)]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">candidate_design</span><span class="p">)</span>

            <span class="c1"># Finally, we return True as if a datapoint is archived, then that state is always accepted per MOSA:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># If we do not archive, we return False to do a probability test:</span>
        <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="MOSA.p_accept">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.p_accept">[docs]</a>
    <span class="k">def</span> <span class="nf">p_accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">old</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function will calculate the individual probability for MOSA</span>

<span class="sd">        :param new: Objective function value for objective i for the MODIFIED design state</span>
<span class="sd">        :param old: Objective function value for objective i for the ORIGINAL design state</span>
<span class="sd">        :param temperature: Current temperature for objective i</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use this to catch computational errors in the exponential:</span>
        <span class="n">overflow_check</span> <span class="o">=</span> <span class="p">((</span><span class="n">new</span> <span class="o">-</span> <span class="n">old</span><span class="p">)</span> <span class="o">/</span> <span class="n">temperature</span><span class="p">)</span>  <span class="c1"># Just checking this value to make sure it&#39;s calculating out</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_function</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_function</span> <span class="o">==</span> <span class="s1">&#39;Standard&#39;</span><span class="p">:</span>
            <span class="c1"># I first check to see if new - old / temperature is greater than a threshold as we are passing these to a</span>
            <span class="c1"># exponential function. This is because I want to avoid the numpy &quot;very large value&quot; warnings as well as</span>
            <span class="c1"># because i want to plot these probability values. A very large value for temp means that the move we are</span>
            <span class="c1"># evaluating is VERY positive to the objective function we are testing (it&#39;s temperature).</span>

            <span class="k">if</span> <span class="n">overflow_check</span> <span class="o">&lt;=</span> <span class="mf">4.6</span><span class="p">:</span>
                <span class="c1"># This threshold of 4.6 correspond to about ~100 (e^-(new-old/temperature) = e^-4. = 100)</span>
                <span class="c1"># I will return &quot;100&quot; as that means we are going to accept this state as the new active state</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">new</span> <span class="o">-</span> <span class="n">old</span><span class="p">))</span> <span class="o">/</span> <span class="n">temperature</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_function</span> <span class="o">==</span> <span class="s1">&#39;logistic&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_function</span> <span class="o">==</span> <span class="s1">&#39;Logistic&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">overflow_check</span> <span class="o">&lt;=</span> <span class="mf">4.6</span><span class="p">:</span>
                <span class="c1"># This threshold of 4.6 correspond to very large values of e, and the larger this e value is the actual</span>
                <span class="c1"># value of temp used in Logistic APF goes to 0 since it uses e(x) instead of e(-x)</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">new</span> <span class="o">-</span> <span class="n">old</span><span class="p">)</span> <span class="o">/</span> <span class="n">temperature</span><span class="p">)</span>  <span class="c1"># Logistic Curve Acceptance Probabilty Function</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">temp</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_function</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_function</span> <span class="o">==</span> <span class="s1">&#39;Linear&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">overflow_check</span> <span class="o">&lt;=</span> <span class="mf">4.6</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>  <span class="c1"># If the threshold is met, we return the value 1 since the APF is min([1, exp])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(((</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">new</span> <span class="o">-</span> <span class="n">old</span><span class="p">))</span> <span class="o">/</span> <span class="n">temperature</span><span class="p">))</span>  <span class="c1"># Scalar linear Acceptance Probabilty Function</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">temp</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid acceptance probability function input&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="MOSA.probability_acceptance">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.probability_acceptance">[docs]</a>
    <span class="k">def</span> <span class="nf">probability_acceptance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_1</span><span class="p">:</span> <span class="n">PolyhedralSpace</span><span class="p">,</span> <span class="n">state_2</span><span class="p">:</span> <span class="n">PolyhedralSpace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function compares two design states and calculates the product probability of acceptance to archive a</span>
<span class="sd">        design stage per the MOSA implementation</span>

<span class="sd">        :param state_1: First state (ie before grammar applied to design) being considered</span>
<span class="sd">        :param state_2: Second state (ie after grammar successfully applied to design) being considered</span>
<span class="sd">        :return: Probability acceptance to use in Metropolis-Hastings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find the objective function values of both design stages:</span>
        <span class="n">old_objectives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_objective_function_values</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="n">state_1</span><span class="p">)</span>
        <span class="n">new_objectives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_objective_function_values</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="n">state_2</span><span class="p">)</span>

        <span class="c1"># Calculate probabilities based on selected schedule:</span>
        <span class="n">tot_prob</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">temperature</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">old_objectives</span><span class="p">,</span> <span class="n">new_objectives</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="c1"># Calculate each probability for all objs.</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_accept</span><span class="p">(</span><span class="n">new</span><span class="o">=</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="n">old</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">temperature</span><span class="p">])</span>
            <span class="c1"># probs.append(prob)</span>
            <span class="n">tot_prob</span> <span class="o">+=</span> <span class="n">prob</span>
        <span class="c1"># product = reduce(mul, probs)</span>
        <span class="n">final_probability</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">tot_prob</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDecimals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final_probability</span></div>



<div class="viewcode-block" id="MOSA.metropolis">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.metropolis">[docs]</a>
    <span class="k">def</span> <span class="nf">metropolis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_accept</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Metropolis-Hastings algorithm implementation</span>

<span class="sd">        :param p_accept: Acceptance probability calculated</span>
<span class="sd">        :return: True: replace the design, False: Use probability test</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">### PER THE MOSA ALGORITHM: Sometimes, p_accept will be greater than unity (1) for a given function. In this</span>
        <span class="c1">#                           case, we will always accept it. This occurs when the difference in the new and</span>
        <span class="c1">#                           old objective function values is very small (and we therefore want to explore this</span>
        <span class="c1">#                           region of the pareto, so we always accept these)</span>
        <span class="k">if</span> <span class="n">p_accept</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Otherwise, in the case of MINIMIZATION (which all of my objective functions are):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_accept_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_accept</span><span class="p">)</span>  <span class="c1"># Append to list for plotting later to verify algorithm</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p_accept</span><span class="p">:</span>
            <span class="c1"># If the random generated point is less than our acceptance probability, we return True to accept the state</span>
            <span class="c1"># Over time, the p_accept should go lower and lower meaning we accept less and less worse states.</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise we do not accept the state and return False</span>
            <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="MOSA.store_objectives_worse_move">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.store_objectives_worse_move">[docs]</a>
    <span class="k">def</span> <span class="nf">store_objectives_worse_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">design_space</span><span class="p">:</span> <span class="n">PolyhedralSpace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stores the objective function values when a worse move was selected (and we track here)</span>

<span class="sd">        design_space: Design space that is currently being evaluated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">objective_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_objective_function_values</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="n">design_space</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objective_vals</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objective_vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_all_temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objective_vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>



<div class="viewcode-block" id="MOSA.quench_temperatures">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.quench_temperatures">[docs]</a>
    <span class="k">def</span> <span class="nf">quench_temperatures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is in charge of cooling the temperature in MOSA with a few different cooling schedules as a</span>
<span class="sd">        potential use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cooling_schedule</span> <span class="o">==</span> <span class="s1">&#39;geometric&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cooling_schedule</span> <span class="o">==</span> <span class="s1">&#39;Geoemtric&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_functions</span><span class="p">)):</span>
                <span class="n">curTemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">curTemp</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cooling_rate_geometric</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curTemp</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cooling_schedule</span> <span class="o">==</span> <span class="s1">&#39;triki&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cooling_schedule</span> <span class="o">==</span> <span class="s1">&#39;Triki&#39;</span><span class="p">:</span>
            <span class="c1"># Using a worst-case-scenario where all measured objectives are the same value, use a constant alpha of .5</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_functions</span><span class="p">)):</span>
                <span class="n">cur_objectives_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">cur_objectives_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cur_objectives_list</span><span class="p">):</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_T</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">cur_objectives_list</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># We set a floor to the lowest the cooling rate can be</span>
                <span class="c1"># After calculating the new Triki cooling rate for this objective, we update tepmerature:</span>
                <span class="n">curTemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">curTemp</span> <span class="o">*=</span> <span class="n">alpha</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curTemp</span>
                <span class="c1"># Also, we reset the tracked objective list:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Should reset the value of self.fX_obj_at_Ti  to []</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cooling_schedule</span> <span class="o">==</span> <span class="s1">&#39;Huang&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cooling_schedule</span> <span class="o">==</span> <span class="s1">&#39;huang&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_functions</span><span class="p">)):</span>
                <span class="n">cur_objectives_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">cur_objectives_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cur_objectives_list</span><span class="p">):</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.7</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">cur_objectives_list</span><span class="p">))))</span>
                <span class="c1"># After calculating the new Triki cooling rate for this objective, we update tepmerature:</span>
                <span class="n">curTemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">curTemp</span> <span class="o">*=</span> <span class="n">alpha</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curTemp</span>
                <span class="c1"># Also, we reset the tracked objective list:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objectives_at_Ti</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid cooling schedule selected, options are: geometric, triki, huang&#39;</span><span class="p">)</span>

        <span class="c1"># Update temperature lists for plotting:</span>
        <span class="k">for</span> <span class="n">obj</span><span class="p">,</span> <span class="n">temp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_temp_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">curList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp_tracker</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
            <span class="n">curList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span></div>



<div class="viewcode-block" id="MOSA.store_pareto_for_animation">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.store_pareto_for_animation">[docs]</a>
    <span class="k">def</span> <span class="nf">store_pareto_for_animation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function takes in the current epoch and stores the required data for plotting an animation or video</span>
<span class="sd">        to see the growth / exploration of the design space from a pareto POV</span>

<span class="sd">        :param epoch: Current optimization epoch number to store the pareto data to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curData</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MOSA_archive</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pareto_animation</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span> <span class="o">=</span> <span class="n">curData</span></div>



<div class="viewcode-block" id="MOSA.begin_MOSA">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.begin_MOSA">[docs]</a>
    <span class="k">def</span> <span class="nf">begin_MOSA</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method starts the optimization process and takes no input / has no output and simply writes out a file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize dictionaries for tracking and generate the initial shape for the input design space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_time_tracker_dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="o">.</span><span class="n">generate_start_shape</span><span class="p">()</span>
        <span class="c1"># If the design space is in precise mode we must generate the first conditions:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="o">.</span><span class="n">use_precise_geometry</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="o">.</span><span class="n">create_precise_files</span><span class="p">()</span>
        <span class="n">all_edge_lengths</span> <span class="o">=</span> <span class="n">calculate_design_edge_lengths</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="o">.</span><span class="n">design_graph</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="o">.</span><span class="n">calculate_input_parameters</span><span class="p">(</span><span class="n">edge_lengths</span><span class="o">=</span><span class="n">all_edge_lengths</span><span class="p">,</span>
                                                     <span class="n">routing_algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">design_constraints</span><span class="o">.</span><span class="n">scaffold_routing_algorithm</span><span class="p">)</span>

        <span class="c1"># Update bounding box:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">update_face_equations</span><span class="p">()</span>

        <span class="c1">### STEP 0: (added this later, oops) Validate that the generated start shape actually passed all design</span>
        <span class="c1"># constraints to ensure that the optimization process can begin:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design_constraints</span><span class="o">.</span><span class="n">create_constraint_dictionary</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="p">)</span>
        <span class="n">passed_all_constraints</span><span class="p">,</span> <span class="n">constraint_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_constraints</span><span class="o">.</span><span class="n">check_constraints</span><span class="p">(</span>
            <span class="n">design_space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="p">,</span> <span class="n">constraint_set</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_set</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">passed_all_constraints</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mango.visualizations.display_mesh_design</span> <span class="kn">import</span> <span class="n">CylindricalRepresentation</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">CylindricalRepresentation</span><span class="p">(</span><span class="n">design</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="p">,</span> <span class="n">bounding_box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">show_bounding_box</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="p">)</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">show_figure</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid input design: The triangulated initial shape did not pass all design constraints&#39;</span>
                            <span class="s1">&#39; of the problem, please review the constraints and initial triangulation of the problem&#39;</span>
                            <span class="s1">&#39; definition. Please reach out to dev team if this is unclear.&#39;</span><span class="p">)</span>

        <span class="c1">### STEP 1:  Initialize temperatures with all available grammars to get a better understanding of the</span>
        <span class="c1">#            design space w/ our grammars:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initializing temperatures for start state&#39;</span><span class="p">)</span>

        <span class="n">passed_init_temps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_temperatures</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">passed_init_temps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_output</span><span class="p">()</span>
            <span class="k">return</span>  <span class="c1"># End due to inability to find &quot;good&quot; solution</span>

        <span class="c1">### STEP 2 of MOSA: Use intelligent Return to Base to reset the reset the current design space along the pareto</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Performing initial return to base&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_to_base</span><span class="p">()</span>

        <span class="c1">### STEP 3 of MOSA: Begin loops of Simulated Annealing with temperature full considered above</span>
        <span class="n">inner_count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Used to track the internal loop count number so we know when to quench</span>
        <span class="n">accepted_count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Used to track the number of accepted moves for quenching</span>
        <span class="n">return_to_base_count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Used to track number of loops so we know when to return to base</span>
        <span class="n">curEpoch</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1">### BEGIN MOSA (Currently a simple exit condition of Sim. Anneal)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>  <span class="c1"># We use this to ensure a run doesn&#39;t go too long.</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_annealing</span><span class="p">(</span><span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">numEpochs</span><span class="o">=</span><span class="n">curEpoch</span><span class="p">):</span>
            <span class="c1"># First we update the ramp extension values.</span>
            <span class="n">extension_map</span><span class="p">,</span> <span class="n">rotation_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extend_and_rotation_values</span><span class="p">(</span><span class="n">epoch</span><span class="o">=</span><span class="n">curEpoch</span><span class="p">)</span>
            <span class="c1"># Step 1: Perturb the current design state into a sample state:</span>
            <span class="n">new_grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span><span class="o">.</span><span class="n">pick_random_grammar</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;Rotation&#39;</span> <span class="ow">in</span> <span class="n">new_grammar</span> <span class="ow">or</span> <span class="s1">&#39;Rotate&#39;</span> <span class="ow">in</span> <span class="n">new_grammar</span> <span class="ow">or</span> <span class="s1">&#39;rotation&#39;</span> <span class="ow">in</span> <span class="n">new_grammar</span><span class="p">:</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">rotation_map</span><span class="p">[</span><span class="n">new_grammar</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">extension_map</span><span class="p">[</span><span class="n">new_grammar</span><span class="p">]</span>

            <span class="c1"># Create two copies of the design_space for comparison:</span>
            <span class="n">active_design_state</span><span class="p">,</span> <span class="n">candidate_design_state</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="p">),</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="p">)</span>

            <span class="c1"># Apply the grammar to the candidate space and check the design constraints:</span>
            <span class="n">grammar_applied_successfully</span><span class="p">,</span> <span class="n">grammar_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar_set</span><span class="o">.</span><span class="n">call_grammar_function</span><span class="p">(</span>
                <span class="n">grammar_selected</span><span class="o">=</span><span class="n">new_grammar</span><span class="p">,</span>
                <span class="n">design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">,</span>
                <span class="n">extension_value</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">grammar_applied_successfully</span><span class="p">:</span>
                <span class="c1"># Update the design constraint values and calculate if design is compliant:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">design_constraints</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">)</span>
                <span class="n">passed_all_constraints</span><span class="p">,</span> <span class="n">constraint_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_constraints</span><span class="o">.</span><span class="n">check_constraints</span><span class="p">(</span>
                    <span class="n">design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">,</span> <span class="n">constraint_set</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_set</span><span class="p">,</span>
                    <span class="n">compare_space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">passed_all_constraints</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># If grammar wasn&#39;t applied don&#39;t both calculating these constraints</span>

            <span class="c1"># For tracking we update the time_tracker for the given grammars:</span>
            <span class="k">if</span> <span class="n">grammar_time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">new_grammar</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_tracker_dict</span><span class="p">[</span><span class="n">new_grammar</span><span class="p">]</span> <span class="o">=</span> <span class="n">grammar_time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_constraint_time_tracker</span><span class="p">(</span><span class="n">new_times</span><span class="o">=</span><span class="n">constraint_times</span><span class="p">)</span>  <span class="c1"># Update tracking of times...</span>

            <span class="k">if</span> <span class="n">passed_all_constraints</span> <span class="ow">and</span> <span class="n">grammar_applied_successfully</span><span class="p">:</span>
                <span class="c1"># If we pass the constraints check AND the grammar applied successfully, we attempt archiving:</span>
                <span class="n">archive_design</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_to_archive</span><span class="p">(</span><span class="n">candidate_design</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">archive_design</span><span class="p">:</span>
                    <span class="c1"># If selected for archiving, the candidate_design_state is set to our new design state:</span>
                    <span class="k">del</span> <span class="n">active_design_state</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update_design_space</span><span class="p">(</span><span class="n">new_design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Otherwise, we use a probability test to determine acceptance:</span>
                    <span class="n">p_accept</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probability_acceptance</span><span class="p">(</span><span class="n">state_1</span><span class="o">=</span><span class="n">active_design_state</span><span class="p">,</span> <span class="n">state_2</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">)</span>
                    <span class="n">accept_new_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metropolis</span><span class="p">(</span><span class="n">p_accept</span><span class="o">=</span><span class="n">p_accept</span><span class="p">)</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Note: Overall, this selection criterion used is a weak point of this MOSA and it is only </span>
<span class="sd">                          recommended for ~two/three objectives. Further research should be conducted here to test the </span>
<span class="sd">                          generalizable to higher number of objective functions. I won&#39;t be going higher than 3 tho as </span>
<span class="sd">                          the actual Pareto is obfuscated due to visualization in 4D or higher being tricky to understand</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">accept_new_state</span><span class="p">:</span>
                        <span class="c1"># If we accept via Metropolis then we set the new state to the active state and store objectives</span>
                        <span class="k">del</span> <span class="n">active_design_state</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">update_design_space</span><span class="p">(</span><span class="n">new_design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">store_objectives_worse_move</span><span class="p">(</span><span class="n">design_space</span><span class="o">=</span><span class="n">candidate_design_state</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">accepted_via_probability</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">total_checked</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">accepted_count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># If we probabilistically accept, we iterate accepted_count</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># If we do not accept via Metropolis, we just continue along with X_N1 as the active state</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">total_checked</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_checked</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># We only start counting once we have passed a constraint check</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_tracker</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">accepted_via_probability</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_checked</span><span class="p">)</span>
            <span class="n">inner_count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Always increment inner_count even if constraints were not passed</span>

            <span class="c1">### PERIODICALLY: Return to base strategy to explore Pareto</span>
            <span class="n">return_to_base_count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment the return to base count to determine when we should next return:</span>
            <span class="k">if</span> <span class="n">return_to_base_count</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_Bi</span><span class="p">:</span>
                <span class="c1"># If we are returning to base, then we call the new state and set it to XN1:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">return_to_base</span><span class="p">()</span>
                <span class="n">return_to_base_count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Reset this count here</span>

            <span class="c1">### PERIODICALLY: Annealing of Temperature per van Laarhoven and Aarts</span>
            <span class="k">if</span> <span class="n">inner_count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NT2</span> <span class="ow">or</span> <span class="n">accepted_count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Na</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inner_count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NT2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;inner count of </span><span class="si">{</span><span class="n">inner_count</span><span class="si">}</span><span class="s1"> exceeded NT2 of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">NT2</span><span class="si">}</span><span class="s1"> at epoch: </span><span class="si">{</span><span class="n">curEpoch</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The value of accepted count was </span><span class="si">{</span><span class="n">accepted_count</span><span class="si">}</span><span class="s1"> at epoch: </span><span class="si">{</span><span class="n">curEpoch</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">accepted_count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Na</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;accepted count of </span><span class="si">{</span><span class="n">accepted_count</span><span class="si">}</span><span class="s1"> exceeded Na of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Na</span><span class="si">}</span><span class="s1"> at epoch: </span><span class="si">{</span><span class="n">curEpoch</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The value of inner_count was </span><span class="si">{</span><span class="n">inner_count</span><span class="si">}</span><span class="s1"> at epoch: </span><span class="si">{</span><span class="n">curEpoch</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">quench_temperatures</span><span class="p">()</span>
                <span class="c1"># Now we update the acceptance_per_epoch tracker:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_per_epoch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_tracker</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_tracker</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Reset to an empty list</span>

                <span class="c1"># After quenching we set the counters for BOTH inner_count and accepted_count to 0 for the next temperature</span>
                <span class="n">inner_count</span><span class="p">,</span> <span class="n">accepted_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">store_pareto_for_animation</span><span class="p">(</span><span class="n">epoch</span><span class="o">=</span><span class="n">curEpoch</span><span class="p">)</span>
                <span class="n">curEpoch</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># When quenching, we add 1 to epoch.</span>


        <span class="c1"># After the while loop concludes / exits, we return the ARCHIVED dataset so we can access any of these values</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_time_seconds</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>

        <span class="c1"># Finally, we save the output by calling the function:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_output</span><span class="p">()</span></div>



<div class="viewcode-block" id="MOSA.save_output">
<a class="viewcode-back" href="../../../mango.optimizers.html#mango.optimizers.multiobjective_simulated_annealing.MOSA.save_output">[docs]</a>
    <span class="k">def</span> <span class="nf">save_output</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is called at the end of a MOSA operation to save the output file</span>

<span class="sd">        :return: Nothing, will simply write a dill binary file containing class information at final iteration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># I am using the &#39;aj1&#39; extension because I want to track which versions of my software can generate which</span>
        <span class="c1"># types of solutions and plots. For example, if I add in features later on I want to differentiate those types</span>
        <span class="c1"># of simulation output.</span>
        <span class="k">def</span> <span class="nf">is_valid_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">re</span>
            <span class="c1"># Define a regular expression for a valid filename (letters, numbers, and underscores only)</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^[a-zA-Z0-9_]+$&#39;</span><span class="p">)</span>

            <span class="c1"># Check if the filename matches the pattern</span>
            <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Check if the save path exists, if not make it:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SAVE_PATH</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SAVE_PATH</span><span class="p">)</span>

        <span class="c1"># Create file:</span>
        <span class="k">if</span> <span class="n">is_valid_filename</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SAVE_NAME_NO_EXTENSION</span><span class="p">):</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SAVE_NAME_NO_EXTENSION</span> <span class="o">+</span> <span class="s1">&#39;.aj1&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Detected an invalid filename, therefore resetting to randomized filename.&quot;</span><span class="p">)</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s1">&#39;MOSA_Export_Data.aj1&#39;</span>

        <span class="n">output_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SAVE_PATH</span><span class="p">,</span> <span class="n">save_name</span><span class="p">)</span>
        <span class="n">copy_of_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">dill</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">copy_of_data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="c1"># Delete the temp files directory if in precise geometry mode:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="o">.</span><span class="n">use_precise_geometry</span><span class="p">:</span>
            <span class="n">full_save_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design_space</span><span class="o">.</span><span class="n">temp_geometry_path</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">full_save_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>
</div>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, A.J. Vetturini.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>